"""Isaiah MumawUniversity of Notre DameCreates all plots used in report for project 1.I recommend using terminal/command line to execute, there are a lot of printstatements that seem to slow down in Spyder.I also suggest not running the whole thing at once, it creates a ton of plots,including some that were not included in the report.Instructions for how to use the different modules are included in the modules."""#user-generated modulesimport linear_combination_schrodinger as lincomimport lanczos_schrodinger as lanczosimport analytical_results as arimport matplotlib.pyplot as pltimport numpy as np############################################################################POTENTIAL ENERGY FUNCTIONSdef harmonic(x,constants):     return 0.5*constants["M"]*(constants["W"]**2.0)*(x**2.0)def harmonic_perturbed(x,constants):     return harmonic(x,constants)+constants["EPS"]*(x**4.0)def double_well(x,constants):     return constants["E0"]*((constants["C"]*x**4)-(x**2))##################################################################################################################################################################################################################################Constants. Adjust as needed, though be aware that you may also have to adjust step size, etc. as well for accurate resultsconstants = {"HBAR":1,"EPS":.1,"M":1,"W":1,"E0":1,"C":.05}#################################################################################################################################################################################################################################"""#FIGURES FROM SECTION 2print("Creating Figures for Section 2")#points to calculate overx_pts = np.linspace(-10,10,2000)#Matrix size convergence testprint("Running convergence test")plt.figure(0)energies, dimensions, levels, convergence = lincom.plot_convergence_test(x_pts,harmonic,lincom.ho,0,10,constants,test_range=40)plt.title("Matrix Dimension Convergence Test")plt.xlabel("Matrix dimension")plt.ylabel("Energy")plt.legend()#Stationary states and energyprint("Plotting stationary states")hamiltonian = lincom.hmatrix(x_pts,harmonic,lincom.ho,constants,nmax=50,progress=True)h_diag,eigenvals,eigenvecs = lincom.diagonalize(hamiltonian)#comparing energies between known and calculated casesplt.figure()n_arr = np.linspace(0,50,50)plt.plot(n_arr,eigenvals,label="Calculated energies")plt.plot(n_arr,n_arr+0.5,label="Known energies")plt.legend()plt.xlabel("Energy level")plt.ylabel("Energy")plt.title("Calculated energies vs. known energies")#ground stateplt.figure()n=0plt.plot(x_pts,lincom.ho(x_pts,n,constants)**2,label="Known state")plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants))**2,label="Calculated State")plt.title("Ground state probability")plt.xlabel("Position")plt.ylabel("Probability")plt.legend()plt.figure()plt.plot(x_pts,lincom.ho(x_pts,n,constants),label="Known state")plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants)),label="Calculated State")plt.title("Ground state wave function")plt.xlabel("Position")plt.ylabel("Amplitude")plt.legend()#excited stateplt.figure()  n=15plt.plot(x_pts,lincom.ho(x_pts,n,constants)**2,label="Known state")plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants))**2,label="Calculated State")plt.title("15th excited state probability")plt.xlabel("Position")plt.ylabel("Probability")plt.legend()plt.figure()plt.plot(x_pts,lincom.ho(x_pts,n,constants),label="Known state")plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants)),label="Calculated State")plt.title("15th excited state wave function")plt.xlabel("Position")plt.ylabel("Amplitude")plt.legend()print("")##################################################################################################################################################################################################################################Figures from section 3print("Creating Figures for Section 3")#Convergence Testsprint("Running range convergence test")plt.figure()for n in range(10):    r_vals, energy_vals, convergence = lanczos.test_range_convergence(2,10,.05,n,harmonic,constants)    print("    n="+str(n)+" converges at |x|="+str(convergence))    plt.plot(r_vals,energy_vals,label="n="+str(n))plt.title("Range Convergence Test")plt.xlabel("Maximum |x|")plt.ylabel("Energy")plt.legend()print("Running step size convergence test")plt.figure()for n in range(10):    h_vals, energy_vals, convergence = lanczos.test_step_convergence(0.01,1,10,n,harmonic,constants)    print("    n="+str(n)+" converges at h="+str(convergence))    plt.plot(h_vals,energy_vals,label="n="+str(n))plt.xlim(max(h_vals),min(h_vals))plt.title("Step Size Convergence Test")plt.xlabel("Step Size")plt.ylabel("Energy")plt.legend()#Comparing Results to known caseprint("Comparing results for different conditions")plt.figure()rmin,rmax = -10,10H=.025x=np.arange(rmin,rmax,H)mat=lanczos.generate_mat(rmin,rmax,H,harmonic,constants)eig_val,eig_vect=lanczos.eigen(mat,rmin,rmax,H)plt.plot(range(len(eig_val)),eig_val,label="Calculated Energies, |x|_max=10, H=.025")rmin,rmax = -20,20H=.05x=np.arange(rmin,rmax,H)mat=lanczos.generate_mat(rmin,rmax,H,harmonic,constants)eig_val,eig_vect=lanczos.eigen(mat,rmin,rmax,H)plt.plot(range(len(eig_val)),eig_val,label="Calculated Energies, |x|_max=20, H=.05")e_harmonic_oscillator=np.arange(0.5,len(eig_val),1)plt.plot(range(len(eig_val)),e_harmonic_oscillator,label="Expected Spectrum")plt.legend()plt.xlabel("Energy Level")plt.ylabel("Energy")plt.title("Calculated energies vs known energies")#Stationary Statesprint("Plotting stationary states")rmin,rmax = -10,10H=.01x=np.arange(rmin,rmax,H)mat=lanczos.generate_mat(rmin,rmax,H,harmonic,constants)eig_val,eig_vect=lanczos.eigen(mat,rmin,rmax,H)#ground stateplt.figure()n=0plt.plot(x,lincom.ho(x,n,constants)**2,label="Known State")plt.plot(x,(eig_vect[:,n])**2,label="Calculated State")plt.title("Ground state probability")plt.xlabel("Position")plt.ylabel("Probability")plt.legend()plt.figure()plt.plot(x,lincom.ho(x,n,constants),label="Known State")plt.plot(x,(eig_vect[:,n]),label="Calculated State")plt.title("Ground state wave function")plt.xlabel("Position")plt.ylabel("Amplitude")plt.legend()#excited stateplt.figure()n=15plt.plot(x,lincom.ho(x,n,constants)**2,label="Known State")plt.plot(x,(eig_vect[:,n])**2,label="Calculated State")plt.title("15th excited state probability")plt.xlabel("Position")plt.ylabel("Probability")plt.legend()plt.figure()plt.plot(x,lincom.ho(x,n,constants),label="Known State")plt.plot(x,(eig_vect[:,n]),label="Calculated State")plt.title("15th excited state wave function")plt.xlabel("Position")plt.ylabel("Amplitude")plt.legend()print("")##################################################################################################################################################################################################################################FIGURES FROM SECTION 4#FROM SUBSECTION 4.1#QUARTIC PERTURBATION TO HARMONIC POTENTIALprint("Creating Figures for Section 4.1 (quartic perturbation)")#variablesx_pts = np.linspace(-10,10,2000)rmin,rmax = -10,10H=.01x=np.arange(rmin,rmax,H)#plot potential functionprint("Plotting perturbed potential function")plt.figure()plt.plot(x_pts,harmonic(x_pts,constants),label="Unperturbed")plt.plot(x_pts,harmonic_perturbed(x_pts,constants),label="Perturbed")plt.axis([-10, 10, -1, 50])plt.title("Comparison of perturbed and unperturbed potentials")plt.legend()plt.xlabel("Position")plt.ylabel("Potential Energy")#Convergence testsprint("Running matrix dimension convergence test for quartic perturbation")plt.figure()energies, dimensions, levels, convergence = lincom.plot_convergence_test(x_pts,harmonic_perturbed,lincom.ho,0,10,constants,test_range=40)plt.title("Matrix Dimension Convergence Test for Quartic Perturbation")plt.xlabel("Array dimension")plt.ylabel("Energy")plt.legend()print("Running range convergence test for quartic perturbation")plt.figure()l_array = np.empty(11)for n in range(11):    r_vals, energy_vals, convergence = lanczos.test_range_convergence(2,10,.05,n,harmonic_perturbed,constants)    print("    n="+str(n)+" converges at |x|="+str(convergence))    plt.plot(r_vals,energy_vals,label="n="+str(n))    l_array[n] = energy_vals[-1]plt.title("Range Convergence Test for Quartic Perturbation")plt.xlabel("Maximum |x|")plt.ylabel("Energy")plt.legend()print("Running step size convergence test for quartic perturbation")plt.figure()for n in range(11):    h_vals, energy_vals, convergence = lanczos.test_step_convergence(0.01,.5,10,n,harmonic_perturbed,constants)    print("    n="+str(n)+" converges at h="+str(convergence))    plt.plot(h_vals,energy_vals,label="n="+str(n))plt.xlim(max(h_vals),min(h_vals))plt.title("Step Size Convergence Test for Quartic Perturbation")plt.xlabel("Step Size")plt.ylabel("Energy")plt.legend()#comparing resultsprint("Comparing calculated energies for quartic perturbation")e_array = np.empty(11)n_array = np.empty(11)for n in range(11):    e_array[n] = ar.Energy_anharmonic_oscillator(constants["EPS"], n)    n_array[n] = n    plt.figure()plt.scatter(n_array,energies[:,-1],label="Linear Combination Method")plt.plot(n_array,l_array,label="Lanczos Algorithm Method")plt.plot(n_array,e_array,label="Perturbation Theory")plt.plot(n_array,(n_array+0.5),label="Unperturbed State")plt.title("Energies found for each method")plt.legend()plt.xlabel("Energy level")plt.ylabel("Energy")#stationary statesprint("Plotting calculated stationary states for quartic perturbation")hamiltonian = lincom.hmatrix(x_pts,harmonic_perturbed,lincom.ho,constants,nmax=50,progress=True)h_diag,eigenvals,eigenvecs = lincom.diagonalize(hamiltonian)mat=lanczos.generate_mat(rmin,rmax,H,harmonic_perturbed,constants)eig_val,eig_vect=lanczos.eigen(mat,rmin,rmax,H)for n in [0,1,2,3,10]:    plt.figure()    plt.plot(x_pts,lincom.ho(x_pts,n,constants)**2,label="Unperturbed state")    plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants))**2,label="Perturbed State, Linear Combination Method")    plt.plot(x,eig_vect[:,n]**2,label="Perturbed State, Lancsoz Algorithm")    plt.title("Probability for state n="+str(n))    plt.xlabel("Position")    plt.ylabel("Probability")    plt.legend()        plt.figure()    plt.plot(x_pts,lincom.ho(x_pts,n,constants),label="Unperturbed state")    plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants)),label="Perturbed State, Linear Combination Method")    plt.plot(x,eig_vect[:,n],label="Perturbed State, Lancsoz Algorithm")    plt.title("Wave function for state n="+str(n))    plt.xlabel("Position")    plt.ylabel("Amplitude")    plt.legend()############################################################################FROM SUBSECTION 4.2#HARMONIC DOUBLE WELLprint("Creating Figures for Section 4.2")#variablesx_pts = np.linspace(-10,10,2000)rmin,rmax = -10,10H=.01x=np.arange(rmin,rmax,H)#plotting potential functionprint("Plotting double well potential")plt.figure()plt.plot(x_pts,double_well(x_pts,constants))plt.axis([-10, 10, -6, 20])plt.title("Double Well Potential")plt.xlabel("Position")plt.ylabel("Potential Energy")#convergence testsprint("Running matrix dimension convergence test for double well")plt.figure()energies, dimensions, levels, convergence = lincom.plot_convergence_test(x_pts,double_well,lincom.ho,0,10,constants,test_range=40)plt.title("Matrix Dimension Convergence Test for Double Well")plt.xlabel("Array dimension")plt.ylabel("Energy")plt.legend()print("Running range convergence test for double well")plt.figure()l_array = np.empty(11)n_array = np.empty(11)for n in range(11):    r_vals, energy_vals, convergence = lanczos.test_range_convergence(2,10,.05,n,double_well,constants)    print("    n="+str(n)+" converges at |x|="+str(convergence))    plt.plot(r_vals,energy_vals,label="n="+str(n))    l_array[n] = energy_vals[-1]    n_array[n] = nplt.title("Range Convergence Test for Double Well")plt.xlabel("Maximum |x|")plt.ylabel("Energy")plt.legend()print("Running step size convergence test for double well")plt.figure()for n in range(11):    h_vals, energy_vals, convergence = lanczos.test_step_convergence(0.01,.5,10,n,double_well,constants)    print("    n="+str(n)+" converges at h="+str(convergence))    plt.plot(h_vals,energy_vals,label="n="+str(n))plt.xlim(max(h_vals),min(h_vals))plt.title("Step Size Convergence Test for Double Well")plt.xlabel("Step Size")plt.ylabel("Energy")plt.legend()plt.figure()plt.plot(n_array,energies[:,-1],label="Linear combination method")plt.plot(n_array,l_array,label="Algorithmic method")plt.legend()plt.title("Comparison of calculated energies")plt.xlabel("Energy level")plt.ylabel("Energy")#stationary statesprint("Plotting calculated stationary states for double well")hamiltonian = lincom.hmatrix(x_pts,double_well,lincom.ho,constants,nmax=50,progress=True)h_diag,eigenvals,eigenvecs = lincom.diagonalize(hamiltonian)mat=lanczos.generate_mat(rmin,rmax,H,double_well,constants)eig_val,eig_vect=lanczos.eigen(mat,rmin,rmax,H)for n in [0,1,2,3,6,7,8,9]:    plt.figure()      plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants))**2,label="Linear Combination Method")    plt.plot(x,eig_vect[:,n]**2,label="Lancsoz Algorithm")    plt.title("Probability for n="+str(n))    plt.xlabel("Position")    plt.ylabel("Probability")    plt.legend()        plt.figure()      plt.plot(x_pts,(lincom.s_state(x_pts,eigenvecs,lincom.ho,n,constants)),label="Linear Combination Method")    plt.plot(x,eig_vect[:,n],label="Lancsoz Algorithm")    plt.title("Wave function for n="+str(n))    plt.xlabel("Position")    plt.ylabel("Amplitude")    plt.legend()print("")"""print("Done")plt.show()